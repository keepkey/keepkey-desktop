/* tslint:disable */
/* eslint-disable */
/**
 * keepkey-desktop
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.1.14
 * Contact: bithighlander@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BTCSignedTx,
  CosmosSignTx,
  CosmosSignedTx,
  ETHSignedMessage,
  ETHSignedTx,
  RippleSignTx,
  RippleTx,
  SignTransaction200Response,
  ThorchainSignTx,
  ThorchainTx,
} from '../models';
import {
    BTCSignedTxFromJSON,
    BTCSignedTxToJSON,
    CosmosSignTxFromJSON,
    CosmosSignTxToJSON,
    CosmosSignedTxFromJSON,
    CosmosSignedTxToJSON,
    ETHSignedMessageFromJSON,
    ETHSignedMessageToJSON,
    ETHSignedTxFromJSON,
    ETHSignedTxToJSON,
    RippleSignTxFromJSON,
    RippleSignTxToJSON,
    RippleTxFromJSON,
    RippleTxToJSON,
    SignTransaction200ResponseFromJSON,
    SignTransaction200ResponseToJSON,
    ThorchainSignTxFromJSON,
    ThorchainSignTxToJSON,
    ThorchainTxFromJSON,
    ThorchainTxToJSON,
} from '../models';

export interface BinanceSignTxRequest {
    body: any | null;
}

export interface BtcSignTxRequest {
    body: any | null;
}

export interface CosmosSignTxRequest {
    cosmosSignTx: CosmosSignTx;
}

export interface EosSignTxRequest {
    body: any | null;
}

export interface EthSignMessageRequest {
    body: any | null;
}

export interface EthSignTxRequest {
    body: any | null;
}

export interface EthSignTypedDataRequest {
    body: any | null;
}

export interface OsmosisSignTxRequest {
    body: any | null;
}

export interface RippleSignTxRequest {
    rippleSignTx: RippleSignTx;
}

export interface SignTransactionRequest {
    body: any | null;
}

export interface ThorchainSignTxRequest {
    thorchainSignTx: ThorchainSignTx;
}

/**
 * 
 */
export class KeepKeySignTxEndpointsApi extends runtime.BaseAPI {

    /**
     */
    async binanceSignTxRaw(requestParameters: BinanceSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling binanceSignTx.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/binanceSignTx`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async binanceSignTx(requestParameters: BinanceSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.binanceSignTxRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async btcSignTxRaw(requestParameters: BtcSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTCSignedTx>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling btcSignTx.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/btcSignTx`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTCSignedTxFromJSON(jsonValue));
    }

    /**
     */
    async btcSignTx(requestParameters: BtcSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTCSignedTx> {
        const response = await this.btcSignTxRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async cosmosSignTxRaw(requestParameters: CosmosSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CosmosSignedTx>> {
        if (requestParameters.cosmosSignTx === null || requestParameters.cosmosSignTx === undefined) {
            throw new runtime.RequiredError('cosmosSignTx','Required parameter requestParameters.cosmosSignTx was null or undefined when calling cosmosSignTx.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/cosmosSignTx`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CosmosSignTxToJSON(requestParameters.cosmosSignTx),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CosmosSignedTxFromJSON(jsonValue));
    }

    /**
     */
    async cosmosSignTx(requestParameters: CosmosSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CosmosSignedTx> {
        const response = await this.cosmosSignTxRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async eosSignTxRaw(requestParameters: EosSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling eosSignTx.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/eosSignTx`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async eosSignTx(requestParameters: EosSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.eosSignTxRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async ethSignMessageRaw(requestParameters: EthSignMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ETHSignedMessage>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling ethSignMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/ethSignMessage`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ETHSignedMessageFromJSON(jsonValue));
    }

    /**
     */
    async ethSignMessage(requestParameters: EthSignMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ETHSignedMessage> {
        const response = await this.ethSignMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async ethSignTxRaw(requestParameters: EthSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ETHSignedTx>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling ethSignTx.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/ethSignTx`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ETHSignedTxFromJSON(jsonValue));
    }

    /**
     */
    async ethSignTx(requestParameters: EthSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ETHSignedTx> {
        const response = await this.ethSignTxRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async ethSignTypedDataRaw(requestParameters: EthSignTypedDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling ethSignTypedData.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/ethSignTypedData`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async ethSignTypedData(requestParameters: EthSignTypedDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.ethSignTypedDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async osmosisSignTxRaw(requestParameters: OsmosisSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling osmosisSignTx.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/osmosisSignTx`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     */
    async osmosisSignTx(requestParameters: OsmosisSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.osmosisSignTxRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async rippleSignTxRaw(requestParameters: RippleSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RippleTx>> {
        if (requestParameters.rippleSignTx === null || requestParameters.rippleSignTx === undefined) {
            throw new runtime.RequiredError('rippleSignTx','Required parameter requestParameters.rippleSignTx was null or undefined when calling rippleSignTx.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/rippleSignTx`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RippleSignTxToJSON(requestParameters.rippleSignTx),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RippleTxFromJSON(jsonValue));
    }

    /**
     */
    async rippleSignTx(requestParameters: RippleSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RippleTx> {
        const response = await this.rippleSignTxRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async signTransactionRaw(requestParameters: SignTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SignTransaction200Response>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling signTransaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/sign`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SignTransaction200ResponseFromJSON(jsonValue));
    }

    /**
     */
    async signTransaction(requestParameters: SignTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SignTransaction200Response> {
        const response = await this.signTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async thorchainSignTxRaw(requestParameters: ThorchainSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ThorchainTx>> {
        if (requestParameters.thorchainSignTx === null || requestParameters.thorchainSignTx === undefined) {
            throw new runtime.RequiredError('thorchainSignTx','Required parameter requestParameters.thorchainSignTx was null or undefined when calling thorchainSignTx.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // api_key authentication
        }

        const response = await this.request({
            path: `/thorchainSignTx`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ThorchainSignTxToJSON(requestParameters.thorchainSignTx),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ThorchainTxFromJSON(jsonValue));
    }

    /**
     */
    async thorchainSignTx(requestParameters: ThorchainSignTxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ThorchainTx> {
        const response = await this.thorchainSignTxRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
