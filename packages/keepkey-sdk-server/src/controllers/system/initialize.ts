import { Body, Middlewares, OperationId, Post, Response, Route, Security, Tags } from 'tsoa'

import { ApiController } from '../../auth'
import { extra } from '../../middlewares'
import type * as types from '../../types'

const assume: <T>(x: unknown) => asserts x is T = () => {}

@Route('/system/initialize')
@Tags('Initialize')
@Security('apiKey')
@Middlewares(extra)
@Response(400, 'Bad request')
@Response(500, 'Error processing request')
export class SystemInitializeController extends ApiController {
  /**
   * Load a device with externally-derived key material. (Not recommended.)
   * @summary Load device
   */
  @Post('/load-device')
  @OperationId('LoadDevice')
  public async loadDevice(
    @Body()
    body: {
      pin?: types.numeric.U32
      passphrase_protection?: boolean
      language?: string
      label?: string
      skip_checksum?: boolean
      u2f_counter?: types.numeric.U32
    } & (
      | /** @title mnemonic */ {
          /** @minLength 1 */
          mnemonic: string
        }
      | /** @title xprv */ {
          /**
           * @minLength 1
           * @pattern ^xprv
           */
          xprv: string
        }
    ),
  ): Promise<void> {
    assume<{ mnemonic?: string }>(body)
    assume<{ xprv?: string }>(body)

    if (body.language !== undefined) throw new Error('loadDevice with language not supported')
    if (body.u2f_counter !== undefined) throw new Error('loadDevice with u2f_counter not supported')
    if (body.xprv !== undefined) {
      throw new Error('loadDevice with xprv not supported')
    }

    await this.context.wallet.loadDevice({
      mnemonic: body.mnemonic ?? '',
      pin: body.pin ? String(body.pin) : undefined,
      passphrase: body.passphrase_protection,
      label: body.label,
      skipChecksum: body.skip_checksum,
    })
  }

  /**
   * Start safe recovery workflow to restore from a recovery sentence.
   * @summary Recover device
   */
  @Post('/recover-device')
  @OperationId('RecoverDevice')
  public async recoverDevice(
    @Body()
    body: {
      /** @isInt */
      word_count: 12 | 18 | 24
      passphrase_protection?: boolean
      pin_protection?: boolean
      language?: string
      label?: string
      /** don't enforce BIP-39 wordlist during the process */
      no_enforce_wordlist?: boolean
      /** screensaver timeout */
      auto_lock_delay_ms?: types.numeric.U32 & unknown
      u2f_counter?: types.numeric.U32
      /** perform dry-run recovery workflow (for safe mnemonic validation) */
      dry_run?: boolean
    },
  ): Promise<void> {
    if (body.dry_run !== undefined) throw new Error('dry-run recovery not supported')
    if (body.no_enforce_wordlist) throw new Error('no_enforce_wordlist not supported')

    await this.context.wallet.recover({
      entropy: (x => {
        switch (x) {
          case 12:
            return 128
          case 18:
            return 192
          case 24:
            return 256
          default:
            throw new Error('unsupported word_count')
        }
      })(body.word_count),
      label: body.label ?? '',
      passphrase: body.passphrase_protection ?? false,
      pin: body.pin_protection ?? false,
      language: body.language,
      autoLockDelayMs: body.auto_lock_delay_ms,
      u2fCounter: body.u2f_counter,
    })
  }

  /**
   * Perform device setup and generate new seed.
   * @summary Set up device
   */
  @Post('/reset-device')
  @OperationId('ResetDevice')
  public async resetDevice(
    @Body()
    body: {
      /** Display entropy generated by the device before asking for additional entropy */
      display_random?: boolean
      /** @isInt */
      strength?: 128 | 192 | 256
      passphrase_protection?: boolean
      pin_protection?: boolean
      language?: string
      label?: string
      /** Initialize without ever showing the recovery sentence */
      no_backup?: boolean
      /** screensaver timeout */
      auto_lock_delay_ms?: types.numeric.U32 & unknown
      u2f_counter?: types.numeric.U32
    },
  ): Promise<void> {
    if (body.display_random) throw new Error('display_random not supported')
    if (body.language !== undefined) throw new Error('language not supported')
    if (body.no_backup) throw new Error('no_backup not supported')

    await this.context.wallet.reset({
      entropy: body.strength,
      label: body.label ?? '',
      passphrase: body.passphrase_protection ?? false,
      pin: body.pin_protection ?? false,
      autoLockDelayMs: body.auto_lock_delay_ms,
      u2fCounter: body.u2f_counter,
    })
  }
}
